-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\hdlcoder_I2C_ssm2603\I2C_SSM2603_src_i2c_mstr.vhd
-- Created: 2020-11-19 16:06:43
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: I2C_SSM2603_src_i2c_mstr
-- Source Path: hdlcoder_I2C_ssm2603/I2C_SSM2603/I2C_MasterController/i2c_mstr
-- Hierarchy Level: 2
-- 
-- I2C Master Controller
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.I2C_SSM2603_src_I2C_SSM2603_pkg.ALL;

ENTITY I2C_SSM2603_src_i2c_mstr IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1                             :   IN    std_logic;
        rd_wr                             :   IN    std_logic;
        mode                              :   IN    std_logic;
        slv_addr                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        reg_addr                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        reg_addr_burstIn                  :   IN    std_logic;
        reg_data                          :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        sda_in                            :   IN    std_logic;
        busy                              :   OUT   std_logic;
        scl                               :   OUT   std_logic;
        sda                               :   OUT   std_logic;
        ack                               :   OUT   std_logic;
        n_ack                             :   OUT   std_logic
        );
END I2C_SSM2603_src_i2c_mstr;


ARCHITECTURE rtl OF I2C_SSM2603_src_i2c_mstr IS

  ATTRIBUTE multstyle : string;

  -- Signals
  SIGNAL slv_addr_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL reg_addr_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL reg_data_unsigned                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL is_i2c_mstr                      : T_state_type_is_i2c_mstr;  -- uint8
  SIGNAL bit_cnt                          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL reg_data_burst                   : std_logic;
  SIGNAL reg_addr_burst                   : std_logic;
  SIGNAL busy_reg                         : std_logic;
  SIGNAL scl_reg                          : std_logic;
  SIGNAL sda_reg                          : std_logic;
  SIGNAL ack_reg                          : std_logic;
  SIGNAL n_ack_reg                        : std_logic;
  SIGNAL reg_data_burst_reg               : std_logic;
  SIGNAL reg_addr_burst_reg               : std_logic;
  SIGNAL is_i2c_mstr_next                 : T_state_type_is_i2c_mstr;  -- enum type state_type_is_i2c_mstr (32 enums)
  SIGNAL bit_cnt_next                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL busy_reg_next                    : std_logic;
  SIGNAL scl_reg_next                     : std_logic;
  SIGNAL sda_reg_next                     : std_logic;
  SIGNAL ack_reg_next                     : std_logic;
  SIGNAL n_ack_reg_next                   : std_logic;
  SIGNAL reg_data_burst_reg_next          : std_logic;
  SIGNAL reg_addr_burst_reg_next          : std_logic;

BEGIN
  slv_addr_unsigned <= unsigned(slv_addr);

  reg_addr_unsigned <= unsigned(reg_addr);

  reg_data_unsigned <= unsigned(reg_data);

  i2c_mstr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      bit_cnt <= to_unsigned(16#00#, 8);
      ack_reg <= '0';
      n_ack_reg <= '0';
      reg_data_burst_reg <= '0';
      reg_addr_burst_reg <= '0';
      --Entry: I2C_SSM2603/I2C_MasterController/i2c_mstr
      --Entry Internal: I2C_SSM2603/I2C_MasterController/i2c_mstr
      --Transition
      is_i2c_mstr <= IN_idle;
      --Entry 'idle'
      scl_reg <= '1';
      sda_reg <= '1';
      busy_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_i2c_mstr <= is_i2c_mstr_next;
        bit_cnt <= bit_cnt_next;
        busy_reg <= busy_reg_next;
        scl_reg <= scl_reg_next;
        sda_reg <= sda_reg_next;
        ack_reg <= ack_reg_next;
        n_ack_reg <= n_ack_reg_next;
        reg_data_burst_reg <= reg_data_burst_reg_next;
        reg_addr_burst_reg <= reg_addr_burst_reg_next;
      END IF;
    END IF;
  END PROCESS i2c_mstr_process;

  i2c_mstr_output : PROCESS (ack_reg, bit_cnt, busy_reg, enb_1, is_i2c_mstr, mode, n_ack_reg, rd_wr,
       reg_addr_burstIn, reg_addr_burst_reg, reg_addr_unsigned,
       reg_data_burst_reg, reg_data_unsigned, scl_reg, sda_in, sda_reg,
       slv_addr_unsigned)
    VARIABLE bm1 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_0 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_1 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_2 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_3 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_4 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_5 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_6 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_7 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_8 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_9 : unsigned(7 DOWNTO 0);
    VARIABLE bm1_10 : unsigned(7 DOWNTO 0);
    VARIABLE sub_cast : signed(8 DOWNTO 0);
    VARIABLE sub_temp : signed(8 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(8 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(8 DOWNTO 0);
    VARIABLE sub_cast_1 : signed(8 DOWNTO 0);
    VARIABLE sub_temp_1 : signed(8 DOWNTO 0);
  BEGIN
    bm1 := to_unsigned(16#00#, 8);
    bm1_0 := to_unsigned(16#00#, 8);
    bm1_1 := to_unsigned(16#00#, 8);
    bm1_2 := to_unsigned(16#00#, 8);
    bm1_3 := to_unsigned(16#00#, 8);
    bm1_4 := to_unsigned(16#00#, 8);
    bm1_5 := to_unsigned(16#00#, 8);
    bm1_6 := to_unsigned(16#00#, 8);
    bm1_7 := to_unsigned(16#00#, 8);
    bm1_8 := to_unsigned(16#00#, 8);
    bm1_9 := to_unsigned(16#00#, 8);
    bm1_10 := to_unsigned(16#00#, 8);
    sub_temp := to_signed(16#000#, 9);
    sub_temp_0 := to_signed(16#000#, 9);
    sub_temp_1 := to_signed(16#000#, 9);
    sub_cast := to_signed(16#000#, 9);
    sub_cast_0 := to_signed(16#000#, 9);
    sub_cast_1 := to_signed(16#000#, 9);
    busy_reg_next <= busy_reg;
    scl_reg_next <= scl_reg;
    sda_reg_next <= sda_reg;
    ack_reg_next <= ack_reg;
    n_ack_reg_next <= n_ack_reg;
    reg_data_burst_reg_next <= reg_data_burst_reg;
    reg_addr_burst_reg_next <= reg_addr_burst_reg;
    is_i2c_mstr_next <= is_i2c_mstr;
    bit_cnt_next <= bit_cnt;
    --Gateway: I2C_SSM2603/I2C_MasterController/i2c_mstr
    --During: I2C_SSM2603/I2C_MasterController/i2c_mstr
    CASE is_i2c_mstr IS
      WHEN IN_Increment_Byte_count =>
        --During 'Increment_Byte_count'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_data_n;
        --Entry 'cmd_reg_data_n'
        scl_reg_next <= '0';
        bm1_5 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_data_unsigned(to_integer(bm1_5));
        ack_reg_next <= '0';
        reg_data_burst_reg_next <= '0';
      WHEN IN_Increment_Byte_count1 =>
        n_ack_reg_next <= '1';
        --During 'Increment_Byte_count1'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_data_n;
        --Entry 'cmd_reg_data_n'
        scl_reg_next <= '0';
        bm1_0 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_data_unsigned(to_integer(bm1_0));
        ack_reg_next <= '0';
        reg_data_burst_reg_next <= '0';
      WHEN IN_ack_addr_m =>
        scl_reg_next <= '0';
        ack_reg_next <= '1';
        --During 'ack_addr_m'
        IF reg_addr_burstIn = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_ack_addrm1;
          --Entry 'ack_addrm1'
          scl_reg_next <= '1';
          ack_reg_next <= '1';
          bit_cnt_next <= to_unsigned(16#08#, 8);
          reg_addr_burst_reg_next <= '1';
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_ack_addr_m_cnf;
          --Entry 'ack_addr_m_cnf'
          scl_reg_next <= '1';
          bit_cnt_next <= to_unsigned(16#08#, 8);
          ack_reg_next <= '1';
        END IF;
      WHEN IN_ack_addr_m_cnf =>
        --During 'ack_addr_m_cnf'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_data_n;
        --Entry 'cmd_reg_data_n'
        scl_reg_next <= '0';
        bm1_1 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_data_unsigned(to_integer(bm1_1));
        ack_reg_next <= '0';
        reg_data_burst_reg_next <= '0';
      WHEN IN_ack_addrm1 =>
        --During 'ack_addrm1'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_addr_n;
        --Entry 'cmd_reg_addr_n'
        scl_reg_next <= '0';
        ack_reg_next <= '0';
        bm1_10 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_addr_unsigned(to_integer(bm1_10));
        reg_addr_burst_reg_next <= '0';
      WHEN IN_ack_data =>
        scl_reg_next <= '0';
        ack_reg_next <= '1';
        --During 'ack_data'
        IF mode = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_Increment_Byte_count;
          --Entry 'Increment_Byte_count'
          scl_reg_next <= '1';
          bit_cnt_next <= to_unsigned(16#08#, 8);
          ack_reg_next <= '1';
          reg_data_burst_reg_next <= '1';
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_ack_data_cnf;
          --Entry 'ack_data_cnf'
          scl_reg_next <= '1';
          ack_reg_next <= '1';
        END IF;
      WHEN IN_ack_data_cnf =>
        --During 'ack_data_cnf'
        --Transition
        is_i2c_mstr_next <= IN_scl_ext_n;
        --Entry 'scl_ext_n'
        scl_reg_next <= '0';
        sda_reg_next <= '0';
        ack_reg_next <= '0';
      WHEN IN_ack_slv =>
        --During 'ack_slv'
        --Transition
        is_i2c_mstr_next <= IN_ack_slv_cnf;
        --Entry 'ack_slv_cnf'
        scl_reg_next <= '1';
        ack_reg_next <= '1';
        bit_cnt_next <= to_unsigned(16#08#, 8);
      WHEN IN_ack_slv_cnf =>
        --During 'ack_slv_cnf'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_addr_n;
        --Entry 'cmd_reg_addr_n'
        scl_reg_next <= '0';
        ack_reg_next <= '0';
        bm1_6 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_addr_unsigned(to_integer(bm1_6));
        reg_addr_burst_reg_next <= '0';
      WHEN IN_cmd_reg_addr_n =>
        ack_reg_next <= '0';
        reg_addr_burst_reg_next <= '0';
        --During 'cmd_reg_addr_n'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_addr_p;
        --Entry 'cmd_reg_addr_p'
        scl_reg_next <= '1';
        sub_cast_0 := signed(resize(bit_cnt, 9));
        sub_temp_0 := sub_cast_0 - to_signed(16#001#, 9);
        IF sub_temp_0(8) = '1' THEN 
          bit_cnt_next <= "00000000";
        ELSE 
          bit_cnt_next <= unsigned(sub_temp_0(7 DOWNTO 0));
        END IF;
      WHEN IN_cmd_reg_addr_p =>
        scl_reg_next <= '1';
        --During 'cmd_reg_addr_p'
        IF bit_cnt > to_unsigned(16#00#, 8) THEN 
          --Transition
          is_i2c_mstr_next <= IN_cmd_reg_addr_n;
          --Entry 'cmd_reg_addr_n'
          scl_reg_next <= '0';
          ack_reg_next <= '0';
          bm1_7 := bit_cnt - to_unsigned(16#01#, 8);
          sda_reg_next <= reg_addr_unsigned(to_integer(bm1_7));
          reg_addr_burst_reg_next <= '0';
        ELSIF ( NOT sda_in) = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_ack_addr_m;
          --Entry 'ack_addr_m'
          scl_reg_next <= '0';
          ack_reg_next <= '1';
          sda_reg_next <= '1';
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_nack_addrm;
          --Entry 'nack_addrm'
          scl_reg_next <= '0';
          sda_reg_next <= '1';
          n_ack_reg_next <= '1';
        END IF;
      WHEN IN_cmd_reg_data_n =>
        ack_reg_next <= '0';
        reg_data_burst_reg_next <= '0';
        --During 'cmd_reg_data_n'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_data_p;
        --Entry 'cmd_reg_data_p'
        scl_reg_next <= '1';
        sub_cast_1 := signed(resize(bit_cnt, 9));
        sub_temp_1 := sub_cast_1 - to_signed(16#001#, 9);
        IF sub_temp_1(8) = '1' THEN 
          bit_cnt_next <= "00000000";
        ELSE 
          bit_cnt_next <= unsigned(sub_temp_1(7 DOWNTO 0));
        END IF;
      WHEN IN_cmd_reg_data_p =>
        scl_reg_next <= '1';
        --During 'cmd_reg_data_p'
        IF bit_cnt > to_unsigned(16#00#, 8) THEN 
          --Transition
          is_i2c_mstr_next <= IN_cmd_reg_data_n;
          --Entry 'cmd_reg_data_n'
          scl_reg_next <= '0';
          bm1_2 := bit_cnt - to_unsigned(16#01#, 8);
          sda_reg_next <= reg_data_unsigned(to_integer(bm1_2));
          ack_reg_next <= '0';
          reg_data_burst_reg_next <= '0';
        ELSIF ( NOT sda_in) = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_ack_data;
          --Entry 'ack_data'
          scl_reg_next <= '0';
          sda_reg_next <= '1';
          ack_reg_next <= '1';
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_nack_data;
          --Entry 'nack_data'
          scl_reg_next <= '0';
          sda_reg_next <= '1';
          n_ack_reg_next <= '1';
        END IF;
      WHEN IN_cmd_slave_addr_n =>
        --During 'cmd_slave_addr_n'
        --Transition
        is_i2c_mstr_next <= IN_cmd_slave_addr_p;
        --Entry 'cmd_slave_addr_p'
        scl_reg_next <= '1';
        sub_cast := signed(resize(bit_cnt, 9));
        sub_temp := sub_cast - to_signed(16#001#, 9);
        IF sub_temp(8) = '1' THEN 
          bit_cnt_next <= "00000000";
        ELSE 
          bit_cnt_next <= unsigned(sub_temp(7 DOWNTO 0));
        END IF;
      WHEN IN_cmd_slave_addr_p =>
        scl_reg_next <= '1';
        --During 'cmd_slave_addr_p'
        IF bit_cnt > to_unsigned(16#00#, 8) THEN 
          --Transition
          is_i2c_mstr_next <= IN_cmd_slave_addr_n;
          --Entry 'cmd_slave_addr_n'
          scl_reg_next <= '0';
          bm1_3 := bit_cnt - to_unsigned(16#01#, 8);
          sda_reg_next <= slv_addr_unsigned(to_integer(bm1_3));
        ELSIF ( NOT rd_wr) = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_write_n;
          --Entry 'write_n'
          scl_reg_next <= '0';
          sda_reg_next <= '0';
        END IF;
      WHEN IN_idle =>
        scl_reg_next <= '1';
        busy_reg_next <= '0';
        --During 'idle'
        IF enb_1 = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_ready;
          --Entry 'ready'
          scl_reg_next <= '1';
          sda_reg_next <= '1';
        END IF;
      WHEN IN_nack_addrm =>
        scl_reg_next <= '0';
        n_ack_reg_next <= '1';
        --During 'nack_addrm'
        IF reg_addr_burstIn = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_nack_addrm1;
          --Entry 'nack_addrm1'
          scl_reg_next <= '1';
          n_ack_reg_next <= '1';
          bit_cnt_next <= to_unsigned(16#08#, 8);
          --reg_mode(:)=1
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_nack_addrm_cnf;
          --Entry 'nack_addrm_cnf'
          scl_reg_next <= '1';
          bit_cnt_next <= to_unsigned(16#08#, 8);
          n_ack_reg_next <= '1';
        END IF;
      WHEN IN_nack_addrm1 =>
        n_ack_reg_next <= '1';
        --During 'nack_addrm1'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_addr_n;
        --Entry 'cmd_reg_addr_n'
        scl_reg_next <= '0';
        ack_reg_next <= '0';
        bm1_8 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_addr_unsigned(to_integer(bm1_8));
        reg_addr_burst_reg_next <= '0';
      WHEN IN_nack_addrm_cnf =>
        n_ack_reg_next <= '1';
        --During 'nack_addrm_cnf'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_data_n;
        --Entry 'cmd_reg_data_n'
        scl_reg_next <= '0';
        bm1_4 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_data_unsigned(to_integer(bm1_4));
        ack_reg_next <= '0';
        reg_data_burst_reg_next <= '0';
      WHEN IN_nack_data =>
        scl_reg_next <= '0';
        n_ack_reg_next <= '1';
        --During 'nack_data'
        IF mode = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_Increment_Byte_count1;
          --Entry 'Increment_Byte_count1'
          scl_reg_next <= '1';
          bit_cnt_next <= to_unsigned(16#08#, 8);
          n_ack_reg_next <= '1';
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_nack_data_cnf;
          --Entry 'nack_data_cnf'
          scl_reg_next <= '1';
          n_ack_reg_next <= '1';
        END IF;
      WHEN IN_nack_data_cnf =>
        n_ack_reg_next <= '1';
        --During 'nack_data_cnf'
        --Transition
        is_i2c_mstr_next <= IN_scl_ext_n;
        --Entry 'scl_ext_n'
        scl_reg_next <= '0';
        sda_reg_next <= '0';
        ack_reg_next <= '0';
      WHEN IN_nack_slv =>
        --During 'nack_slv'
        --Transition
        is_i2c_mstr_next <= IN_nack_slv_cnf;
        --Entry 'nack_slv_cnf'
        scl_reg_next <= '1';
        bit_cnt_next <= to_unsigned(16#08#, 8);
        n_ack_reg_next <= '1';
      WHEN IN_nack_slv_cnf =>
        n_ack_reg_next <= '1';
        --During 'nack_slv_cnf'
        --Transition
        is_i2c_mstr_next <= IN_cmd_reg_addr_n;
        --Entry 'cmd_reg_addr_n'
        scl_reg_next <= '0';
        ack_reg_next <= '0';
        bm1_9 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= reg_addr_unsigned(to_integer(bm1_9));
        reg_addr_burst_reg_next <= '0';
      WHEN IN_ready =>
        --During 'ready'
        --Transition
        is_i2c_mstr_next <= IN_start_n;
        --Entry 'start_n'
        scl_reg_next <= '1';
        sda_reg_next <= '0';
        bit_cnt_next <= to_unsigned(16#07#, 8);
        busy_reg_next <= '1';
      WHEN IN_scl_ext_n =>
        --During 'scl_ext_n'
        --Transition
        is_i2c_mstr_next <= IN_scl_ext_p;
        --Entry 'scl_ext_p'
        scl_reg_next <= '1';
        sda_reg_next <= '0';
        ack_reg_next <= '0';
      WHEN IN_scl_ext_p =>
        scl_reg_next <= '1';
        ack_reg_next <= '0';
        --During 'scl_ext_p'
        --Transition
        is_i2c_mstr_next <= IN_stop;
        --Entry 'stop'
        sda_reg_next <= '0';
      WHEN IN_start_n =>
        scl_reg_next <= '1';
        busy_reg_next <= '1';
        --During 'start_n'
        --Transition
        is_i2c_mstr_next <= IN_start_p;
        --Entry 'start_p'
        sda_reg_next <= '0';
      WHEN IN_start_p =>
        --During 'start_p'
        --Transition
        is_i2c_mstr_next <= IN_cmd_slave_addr_n;
        --Entry 'cmd_slave_addr_n'
        scl_reg_next <= '0';
        bm1 := bit_cnt - to_unsigned(16#01#, 8);
        sda_reg_next <= slv_addr_unsigned(to_integer(bm1));
      WHEN IN_stop =>
        --During 'stop'
        --Transition
        is_i2c_mstr_next <= IN_stop_ext;
        --Entry 'stop_ext'
        scl_reg_next <= '1';
        sda_reg_next <= '1';
        ack_reg_next <= '0';
      WHEN IN_stop_ext =>
        ack_reg_next <= '0';
        --During 'stop_ext'
        --Transition
        is_i2c_mstr_next <= IN_idle;
        --Entry 'idle'
        scl_reg_next <= '1';
        sda_reg_next <= '1';
        busy_reg_next <= '0';
      WHEN IN_write_n =>
        --During 'write_n'
        --Transition
        is_i2c_mstr_next <= IN_write_p;
        --Entry 'write_p'
        scl_reg_next <= '1';
        sda_reg_next <= '0';
      WHEN OTHERS => 
        --case IN_write_p:
        scl_reg_next <= '1';
        --During 'write_p'
        IF ( NOT sda_in) = '1' THEN 
          --Transition
          is_i2c_mstr_next <= IN_ack_slv;
          --Entry 'ack_slv'
          scl_reg_next <= '0';
          ack_reg_next <= '1';
          sda_reg_next <= '1';
        ELSE 
          --Transition
          is_i2c_mstr_next <= IN_nack_slv;
          --Entry 'nack_slv'
          scl_reg_next <= '0';
          sda_reg_next <= '1';
          n_ack_reg_next <= '1';
        END IF;
    END CASE;
  END PROCESS i2c_mstr_output;

  busy <= busy_reg_next;
  scl <= scl_reg_next;
  sda <= sda_reg_next;
  ack <= ack_reg_next;
  n_ack <= n_ack_reg_next;
  reg_data_burst <= reg_data_burst_reg_next;
  reg_addr_burst <= reg_addr_burst_reg_next;

END rtl;

